require 'pry'
require 'plaid'
require 'clearbit'
require 'logger'
require 'set'

require 'active_support'
require 'active_support/core_ext/numeric/time'
require 'active_support/core_ext/integer/time'

require_relative 'lib/plaid/models/transaction'

# Abstract all the Plaid & Clearbit APIs. Provides some helpers
# to use Plaid Transactions product, Clearbit Enrich API and
# Clearbit Name to Domain API
# @author gomezhyuuga <gomezhyuuga@gmail.com>
#
# @attr_reader [String] public_token Plaid public token generated by Plaid Link (Login Webview).
# @attr_reader [String] access_token Plaid access token provided when you login correctly
#   using a public token.
# @attr [Array] domains List of company domains gathered using the Clearbit Name to Domain.
#   API. By default it is populated from the company names contained in the transactions list.
# @attr [Array] companies List of the enriched companies fetched using Clearbit Enrich.
class API
  attr_reader :public_token, :access_token
  attr_accessor :domains, :companies
  attr_writer :transactions

  # @param [Hash] plaid_credentials API Keys for connecting to Plaid
  # @option plaid_credentials [String] client_id
  # @option plaid_credentials [String] secret
  # @option plaid_credentials [String] public_key
  # @param [String] clearbit_key Clearbit's API Key
  def initialize(plaid_credentials: {}, clearbit_key: {})
    @public_token = ''
    @access_token = ''
    @transactions = []
    @domains      = {}
    @companies    = {}
    @logger       = Logger.new(STDOUT)

    Clearbit.key = clearbit_key

    client_id, secret, public_key = plaid_credentials.values_at('client_id', 'secret', 'public_key')
    @plaid = Plaid::Client.new(env: :sandbox, client_id: client_id,
                               secret: secret, public_key: public_key)
  end

  # Returns the transactions from Plaid
  # It also invokes the methods to enrich the domain information
  #
  # e.g:
  #
  # `@api.transactions(offset: 0, count: 10)` => returns the first 10 transactions
  #
  # `@api.transactions(offset: 10, count: 10)` => returns the 10th to 20th transactions
  #
  # @param [number] count how many transactions retrieve per batch
  # @param [number] offset index to start fetching (to paginate results)
  # @return [array] the list of transactions paginated by `count`
  def transactions(offset: 0, count: 10)
    data = @transactions.empty? ? fetch_transactions() : @transactions
    data[offset...(offset + count)]
  end

  def fetch_transactions
    @transactions = @plaid.transactions.get(@access_token, 6.months.ago, Date.today)
    @transactions = @transactions['transactions']
    fetch_domains()
    enrich_domains()
    find_recurring()
    @transactions
  end

  # Requests an access token to Plaid's API
  # @param [string] public_token a token generated by Plaid Link from
  # a sucessfully login
  def generate_access_token(public_token)
    @public_token     = public_token
    exchange_response = @plaid.item.public_token.exchange(@public_token)
    @access_token     = exchange_response.access_token
    @logger.info "access token: #{@access_token}"
    exchange_response
  end

  # @return [true, false] `true` if there exists an (see {#access_token}) (Plaid logged in successfully),
  #   `false` otherwise.
  def logged_in?
    !@access_token.empty?
  end

  # Uses Clearbit's Name to Domain API to get the information
  # for each transaction
  def fetch_domains
    return if @transactions.empty?

    companies = @transactions.map { |t| self.class.clean_name(t['name']) }

    query = companies.uniq # to avoid repeated queries
    query -= @domains.keys # cache, only retrieve new companies
    @logger.debug("Fetching info for #{query.length} companies")
    @domains.merge!(query.map { |name| [name, domain_lookup(name)] }.to_h)
    @logger.debug(@domains)
    @domains
  end

  # Fetch information for the current {#domains} name using
  # Clearbit's Name to Domain
  # @see https://dashboard.clearbit.com/docs#name-to-domain-api
  # return [Array] list of of the companies
  def enrich_domains
    return {} if @domains.empty?

    query = @domains.keys - @companies.keys # only new domains
    @logger.debug("Enrich for #{query.length} companies...")
    response = query.map { |name| enrich(name, @domains[name]) }
    @companies.merge!(response.map { |x| [x[:company], x[:info]] }.to_h)
    @logger.debug("#{@companies.length} companies enriched!")
    @logger.debug(@companies.keys)
    @logger.debug('Sample:')
    @logger.debug(@companies.first)
    @companies
  end

  # Retrieves enriched information for a company.
  # @see https://dashboard.clearbit.com/docs#enrichment-api Clearbit Docs for more information
  # @param [String] company_name The name of the company. It should exist in {#companies}
  # @return [Hash] information of the company from Clearbit
  def company_info(company_name)
    @companies[self.class.clean_name(company_name)]
  end

  # Finds recurring transactions
  # The algorithm is as follows:
  #
  # 1. Create an index of transactions by date
  # 1. Iterate for each transaction and test:
  #   1. If there is a transaction in the previous month
  #      with the __same name and same amount__, assign it as
  #      recurring
  # @note this method __mutates__ the @transactions variable
  # @return [array] array of transaction id's which are recurring
  def find_recurring
    return if @transactions.empty?
    @logger.debug('Finding recurring transactions...')

    date_index = @transactions.group_by { |t| t['date'] }
    recurring = Set.new
    @transactions.each do |t|
      date  = Date.parse(t['date'])
      prev  = date.months_ago(1).to_s
      match = find_match(t, date_index[prev])

      next unless match

      match['recurring'] = true
      t['recurring']     = true
      recurring << t['transaction_id']
      recurring << match['transaction_id']
    end

    @logger.debug("Found #{recurring.length} recurring transactions.")
    recurring.to_a
  end

  # Removes special characters from a company name in order
  # to fetch it from Clearbit Enrich.
  #
  # It uses the following gsub expression: `/[^A-Za-z\s]/`
  # Then it squeezes the string and finally returns the stripped version.
  #
  # @param [String] company_name Name of the company as given in a transaction.
  # @return [String] Company name cleaned
  def self.clean_name(company_name)
    name = company_name.gsub(/[^A-Za-z\s]/, '')
    name.gsub! 'SFPOOL', '' # Hard-coded hack for UberPOOL Transactions
    name.squeeze! ' ' # Remove double spaces
    name.strip
  end

  private

  def find_match(transaction, list)
    return unless list
    list.find do |x|
      x_day = Date.parse(x['date']).mday
      t_day = Date.parse(transaction['date']).mday

      x['amount'] == transaction['amount'] &&
        x['name'] == transaction['name'] &&
        x_day == t_day
    end
  end

  def domain_lookup(company)
    Clearbit::NameDomain.find(name: company)
  end

  def enrich(company, domain_info)
    return { company: company, info: nil } unless domain_info

    domain = domain_info['domain']
    name   = domain_info['name']
    info   = Clearbit::Enrichment::Company.find(domain: domain, company_name: name)

    { company: company, info: info }
  end
end
